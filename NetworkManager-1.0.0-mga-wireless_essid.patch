From 1247087e3a172456cd3265de7fc8af0311fe5c32 Mon Sep 17 00:00:00 2001
From: Colin Guthrie <colin@mageia.org>
Date: Thu, 29 Jan 2015 09:12:53 +0000
Subject: [PATCH 2/2] ifcfg-rh: Add support for parsing WIRELESS_ESSID= key
 from ifcfg files.

Taken from older patch (r135361 in package SVN), but adapted by
Colin Guthrie <colin@mageia.org> for latest NM.

Originally from Mandriva package.
---
 src/settings/plugins/ifcfg-rh/reader.c | 54 +++++++++++++++++++++++++++++++++-
 1 file changed, 53 insertions(+), 1 deletion(-)

diff --git a/src/settings/plugins/ifcfg-rh/reader.c b/src/settings/plugins/ifcfg-rh/reader.c
index b66d20a..607efb7 100644
--- a/src/settings/plugins/ifcfg-rh/reader.c
+++ b/src/settings/plugins/ifcfg-rh/reader.c
@@ -293,6 +293,43 @@ discover_mac_address(shvarFile *ifcfg, GError **error)
 	return value;
 }
 
+/* Mandriva/Mageia does not seem to ever hex-encode SSID in ifcfg. So do not bother
+ * as well - just get what we have. This highly simplifies the logic */
+/* FIXME this currently fails for '\0' which is not accepted as input either */
+static GBytes *
+ifcfg_mga_parse_ssid(char *value, GError **error)
+{
+	  gsize ssid_len;
+	  gchar *ssid = NULL;
+	  GBytes *bytes;
+	  ssid = g_strdup(value);
+	  if (!ssid) {
+	    g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			 "Cannot duplicate SSID");
+	    return NULL;
+	  }
+
+	  svUnescape (ssid);
+	  ssid_len = strlen (ssid);
+	  if (ssid_len > 32 || ssid_len == 0) {
+		  g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			       "Invalid SSID '%s' (size %zu not between 1 and 32 inclusive)",
+			       value, ssid_len);
+		  g_free(ssid);
+		  return NULL;
+	  }
+
+	  bytes = g_bytes_new (ssid, ssid_len);
+	  if (!bytes) {
+		  g_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,
+			       "Cannot allocate SSID");
+		  g_free(ssid);
+		  return NULL;
+	  }
+	  g_free(ssid);
+	  return bytes;
+}
+
 /* Returns TRUE on missing address or valid address */
 static gboolean
 read_ip4_address (shvarFile *ifcfg,
@@ -3287,6 +3324,7 @@ make_wireless_setting (shvarFile *ifcfg,
 	NMSettingWireless *s_wireless;
 	char *value = NULL;
 	gint64 chan = 0;
+	gboolean has_mga_ssid = FALSE;
 
 	s_wireless = NM_SETTING_WIRELESS (nm_setting_wireless_new ());
 
@@ -3317,7 +3355,21 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_free (value);
 	}
 
-	value = svGetValue (ifcfg, "ESSID", TRUE);
+	value = svGetValue (ifcfg, "WIRELESS_ESSID", TRUE);
+	if (value) {
+	  GBytes *bytes = NULL;
+		bytes = ifcfg_mga_parse_ssid (value, error);
+	  g_free (value);
+
+	  if (bytes) {
+	    has_mga_ssid = TRUE;
+	    g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, bytes, NULL);
+	    g_bytes_unref (bytes);
+	  }
+	}
+	value = NULL;
+	if (!has_mga_ssid)
+	  value = svGetValue (ifcfg, "ESSID", TRUE);
 	if (value) {
 		GBytes *bytes = NULL;
 		gsize ssid_len = 0;
-- 
2.2.2

