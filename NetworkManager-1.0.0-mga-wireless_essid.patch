--- NetworkManager-1.0.0/src/settings/plugins/ifcfg-rh/reader.c.0065~	2015-01-07 10:33:39.994636036 +0100
+++ NetworkManager-1.0.0/src/settings/plugins/ifcfg-rh/reader.c	2015-01-07 10:34:00.130606558 +0100
@@ -250,6 +250,45 @@ make_connection_setting (const char *fil
 
 	return NM_SETTING (s_con);
 }
+/* Mandriva does not seem to ever hex-encode SSID in ifcfg. So do not bother
+ * as well - just get what we have. This highly simplifies the logic */
+/* FIXME this currently fails for '\0' which is not accepted as input either */
+static GByteArray *
+ifcfg_mdv_parse_ssid(char *value, GError **error)
+	{
+	  gsize ssid_len;
+	  gchar *ssid = NULL;
+	  GByteArray *a;
+	  ssid = g_strdup(value);
+	  if (!ssid) {
+	    g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+			 "Cannot duplicate SSID");
+	    goto error;
+	  }
+	  svUnescape (ssid);
+	  ssid_len = strlen (ssid);
+	  if (ssid_len > 32 || ssid_len == 0) {
+		  g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+			       "Invalid SSID '%s' (size %zu not between 1 and 32 inclusive)",
+			       value, ssid_len);
+		  goto error;    
+	  }
+	  a = g_byte_array_sized_new (ssid_len);
+	  if (!a) {
+		  g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+			       "Cannot allocate SSID");
+		  goto error;   
+	  }
+	  g_byte_array_append (a, (const guint8 *) ssid, ssid_len);
+	  g_free(ssid);
+	  return a;
+error:
+	  g_free(ssid);
+	  return NULL;
+	  
+	}
+
+
 
 /* Returns TRUE on missing address or valid address */
 discover_mac_address(shvarFile *ifcfg, GByteArray **array, GError **error)
@@ -2368,6 +2407,7 @@ eap_simple_reader (const char *eap_metho
 {
 	NMSettingSecretFlags flags;
 	char *value;
+	int has_mdv_ssid = 0;
 
 	value = svGetValue (ifcfg, "IEEE_8021X_IDENTITY", FALSE);
 	if (!value) {
@@ -3292,8 +3332,20 @@ make_wireless_setting (shvarFile *ifcfg,
 		g_strfreev (strv);
 		g_free (value);
 	}
-
-	value = svGetValue (ifcfg, "ESSID", TRUE);
+	value = svGetValue (ifcfg, "WIRELESS_ESSID", TRUE);
+	if (value) {
+	  array = ifcfg_mdv_parse_ssid (value, error);
+	  g_free (value);
+	  
+	  if (array) {
+	    has_mdv_ssid = 1;
+	    g_object_set (s_wireless, NM_SETTING_WIRELESS_SSID, array, NULL);
+	    g_byte_array_free (array, TRUE); 
+	  }
+	}
+	value = NULL;
+	if (!has_mdv_ssid)
+	  value = svGetValue (ifcfg, "ESSID", TRUE);
 	if (value) {
 		GBytes *bytes = NULL;
 		gsize ssid_len = 0;
